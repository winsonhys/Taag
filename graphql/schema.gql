type Query {
  shopItems(where: ShopItemWhereInput, orderBy: [ShopItemOrderByInput!], cursor: ShopItemWhereUniqueInput, take: Int, skip: Int, distinct: [ShopItemDistinctFieldEnum!]): [ShopItem!]!
  shopItem(where: ShopItemWhereUniqueInput!): ShopItem
  user(where: UserWhereUniqueInput!): User
  findMultiCartsByUserId(findMultiOrderByUserIdInput: FindMultiOrderByUserIdInput!): MultiOrder!
  findOrdersFromOwnerId(ownerId: String!): [Order!]!
  getPaymentInfo(getPaymentInfoInput: GetPaymentInfoInput!): [PaymentMethod!]!
  getAddresses: [AddressWithDefault!]!
  findUserById(id: String!): User!
}

input ShopItemWhereInput {
  AND: [ShopItemWhereInput!]
  OR: [ShopItemWhereInput!]
  NOT: [ShopItemWhereInput!]
  id: StringFilter
  createdAt: DateTimeFilter
  name: StringFilter
  description: StringFilter
  price: FloatFilter
  imageUrl: StringFilter
  shop: ShopWhereInput
  shopId: StringFilter
  orderItemCounts: OrderItemCountListRelationFilter
  refunds: RefundListRelationFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input DateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input FloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

input NestedFloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

input ShopWhereInput {
  AND: [ShopWhereInput!]
  OR: [ShopWhereInput!]
  NOT: [ShopWhereInput!]
  id: StringFilter
  email: StringFilter
  username: StringFilter
  password: StringFilter
  shopItems: ShopItemListRelationFilter
}

input ShopItemListRelationFilter {
  every: ShopItemWhereInput
  some: ShopItemWhereInput
  none: ShopItemWhereInput
}

input OrderItemCountListRelationFilter {
  every: OrderItemCountWhereInput
  some: OrderItemCountWhereInput
  none: OrderItemCountWhereInput
}

input OrderItemCountWhereInput {
  AND: [OrderItemCountWhereInput!]
  OR: [OrderItemCountWhereInput!]
  NOT: [OrderItemCountWhereInput!]
  id: StringFilter
  orderId: StringFilter
  order: OrderWhereInput
  itemId: StringFilter
  shopItem: ShopItemWhereInput
  price: FloatFilter
  count: IntFilter
  deletedAt: DateTimeNullableFilter
}

input OrderWhereInput {
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
  id: StringFilter
  ownerId: StringFilter
  owner: UserWhereInput
  paymentIntentId: StringNullableFilter
  price: FloatFilter
  orderItemCount: OrderItemCountWhereInput
  MultiOrder: MultiOrderWhereInput
  multiOrderId: StringNullableFilter
  PaymentOrder: PaymentOrderWhereInput
  deletedAt: DateTimeNullableFilter
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: StringFilter
  email: StringFilter
  username: StringFilter
  password: StringFilter
  dob: DateTimeFilter
  orders: OrderListRelationFilter
  stripe_cust_id: StringFilter
  defaultAddressId: StringNullableFilter
  addresses: AddressListRelationFilter
}

input OrderListRelationFilter {
  every: OrderWhereInput
  some: OrderWhereInput
  none: OrderWhereInput
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input AddressListRelationFilter {
  every: AddressWhereInput
  some: AddressWhereInput
  none: AddressWhereInput
}

input AddressWhereInput {
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
  id: StringFilter
  country: StringFilter
  city: StringFilter
  state: StringFilter
  line1: StringFilter
  line2: StringFilter
  postal_code: StringFilter
  userId: StringFilter
  user: UserWhereInput
}

input MultiOrderWhereInput {
  AND: [MultiOrderWhereInput!]
  OR: [MultiOrderWhereInput!]
  NOT: [MultiOrderWhereInput!]
  id: StringFilter
  orders: OrderListRelationFilter
  paymentIntentId: StringNullableFilter
  PaymentMultiOrder: PaymentMultiOrderWhereInput
}

input PaymentMultiOrderWhereInput {
  AND: [PaymentMultiOrderWhereInput!]
  OR: [PaymentMultiOrderWhereInput!]
  NOT: [PaymentMultiOrderWhereInput!]
  id: StringFilter
  paymentStatus: EnumPaymentStatusFilter
  multiOrderId: StringFilter
  multiOrder: MultiOrderWhereInput
  paymentIntentId: StringFilter
}

input EnumPaymentStatusFilter {
  equals: PaymentStatus
  in: [PaymentStatus!]
  notIn: [PaymentStatus!]
  not: NestedEnumPaymentStatusFilter
}

enum PaymentStatus {
  UNPAID
  AWAITING_CATURE
  PAID
  REFUNDED
}

input NestedEnumPaymentStatusFilter {
  equals: PaymentStatus
  in: [PaymentStatus!]
  notIn: [PaymentStatus!]
  not: NestedEnumPaymentStatusFilter
}

input PaymentOrderWhereInput {
  AND: [PaymentOrderWhereInput!]
  OR: [PaymentOrderWhereInput!]
  NOT: [PaymentOrderWhereInput!]
  id: StringFilter
  paymentStatus: EnumPaymentStatusFilter
  orderId: StringFilter
  order: OrderWhereInput
  paymentIntentId: StringFilter
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeNullableFilter
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeNullableFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input NestedIntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input RefundListRelationFilter {
  every: RefundWhereInput
  some: RefundWhereInput
  none: RefundWhereInput
}

input RefundWhereInput {
  AND: [RefundWhereInput!]
  OR: [RefundWhereInput!]
  NOT: [RefundWhereInput!]
  id: StringFilter
  shopItem: ShopItemWhereInput
  shopItemId: StringFilter
  description: StringFilter
  paymentIntentId: StringFilter
  stripeRefundId: StringFilter
}

input ShopItemOrderByInput {
  id: SortOrder
  createdAt: SortOrder
  name: SortOrder
  description: SortOrder
  price: SortOrder
  imageUrl: SortOrder
  shopId: SortOrder
}

enum SortOrder {
  asc
  desc
}

input ShopItemWhereUniqueInput {
  id: String
}

enum ShopItemDistinctFieldEnum {
  id
  createdAt
  name
  description
  price
  imageUrl
  shopId
}

type ShopItem {
  id: String!
  createdAt: DateTime!
  name: String!
  description: String!
  price: Float!
  imageUrl: String!
  shopId: String!
  shop: Shop!
  orderItemCounts(where: OrderItemCountWhereInput, orderBy: [OrderItemCountOrderByInput!], cursor: OrderItemCountWhereUniqueInput, take: Int, skip: Int, distinct: [OrderItemCountDistinctFieldEnum!]): [OrderItemCount!]
  refunds(where: RefundWhereInput, orderBy: [RefundOrderByInput!], cursor: RefundWhereUniqueInput, take: Int, skip: Int, distinct: [RefundDistinctFieldEnum!]): [Refund!]
}

type Shop {
  id: String!
  email: String!
  username: String!
  password: String!
}

input OrderItemCountOrderByInput {
  id: SortOrder
  orderId: SortOrder
  itemId: SortOrder
  price: SortOrder
  count: SortOrder
  deletedAt: SortOrder
}

input OrderItemCountWhereUniqueInput {
  id: String
}

enum OrderItemCountDistinctFieldEnum {
  id
  orderId
  itemId
  price
  count
  deletedAt
}

type OrderItemCount {
  id: String!
  orderId: String!
  itemId: String!
  price: Float!
  count: Int!
  deletedAt: DateTime
  shopItem: ShopItem!
}

input RefundOrderByInput {
  id: SortOrder
  shopItemId: SortOrder
  description: SortOrder
  paymentIntentId: SortOrder
  stripeRefundId: SortOrder
}

input RefundWhereUniqueInput {
  id: String
}

enum RefundDistinctFieldEnum {
  id
  shopItemId
  description
  paymentIntentId
  stripeRefundId
}

type Refund {
  id: String!
  shopItemId: String!
  description: String!
  paymentIntentId: String!
  stripeRefundId: String!
}

input UserWhereUniqueInput {
  id: String
  email: String
  username: String
}

type User {
  id: String!
  email: String!
  username: String!
  password: String!
  dob: DateTime!
  stripe_cust_id: String!
  defaultAddressId: String
  orders(where: OrderWhereInput, orderBy: [OrderOrderByInput!], cursor: OrderWhereUniqueInput, take: Int, skip: Int, distinct: [OrderDistinctFieldEnum!]): [Order!]
  addresses(where: AddressWhereInput, orderBy: [AddressOrderByInput!], cursor: AddressWhereUniqueInput, take: Int, skip: Int, distinct: [AddressDistinctFieldEnum!]): [Address!]
}

input OrderOrderByInput {
  id: SortOrder
  ownerId: SortOrder
  paymentIntentId: SortOrder
  price: SortOrder
  multiOrderId: SortOrder
  deletedAt: SortOrder
}

input OrderWhereUniqueInput {
  id: String
}

enum OrderDistinctFieldEnum {
  id
  ownerId
  paymentIntentId
  price
  multiOrderId
  deletedAt
}

type Order {
  id: String!
  ownerId: String!
  paymentIntentId: String
  price: Float!
  multiOrderId: String
  deletedAt: DateTime
  owner: User!
  orderItemCount: OrderItemCount!
  MultiOrder: MultiOrder
  PaymentOrder: PaymentOrder
}

type MultiOrder {
  id: String!
  paymentIntentId: String
  orders(where: OrderWhereInput, orderBy: [OrderOrderByInput!], cursor: OrderWhereUniqueInput, take: Int, skip: Int, distinct: [OrderDistinctFieldEnum!]): [Order!]
  PaymentMultiOrder: PaymentMultiOrder
}

type PaymentMultiOrder {
  id: String!
  paymentStatus: PaymentStatus!
  multiOrderId: String!
  paymentIntentId: String!
}

type PaymentOrder {
  id: String!
  paymentStatus: PaymentStatus!
  orderId: String!
  paymentIntentId: String!
}

input AddressOrderByInput {
  id: SortOrder
  country: SortOrder
  city: SortOrder
  state: SortOrder
  line1: SortOrder
  line2: SortOrder
  postal_code: SortOrder
  userId: SortOrder
}

input AddressWhereUniqueInput {
  id: String
}

enum AddressDistinctFieldEnum {
  id
  country
  city
  state
  line1
  line2
  postal_code
  userId
}

type Address {
  id: String!
  country: String!
  city: String!
  state: String!
  line1: String!
  line2: String!
  postal_code: String!
  userId: String!
}

input FindMultiOrderByUserIdInput {
  user_id: String!
}

input GetPaymentInfoInput {
  stripe_cust_id: String!
}

type PaymentMethod {
  id: String!
  billing_details: StripeCardBillingDetails!
  card: StripeCard!
  created: Float!
  customer: String!
  livemode: Boolean!
}

type StripeCardBillingDetails {
  address: StripeCardBillingAddress!
  email: String!
  name: String!
  phone: String!
}

type StripeCardBillingAddress {
  city: String!
  country: String!
  line1: String!
  line2: String!
  postal_code: String!
  state: String!
}

type StripeCard {
  brand: String!
  country: String!
  description: String!
  exp_month: Float!
  exp_year: Float!
  fingerprint: String!
  funding: String!
  iin: String!
  issuer: String!
  last4: String!
  networks: StripeCardNetworks!
  three_d_secure_usage: StripeCardThreeDSecureUsage!
}

type StripeCardNetworks {
  available: [String!]!
  preferred: String!
}

type StripeCardThreeDSecureUsage {
  supported: Boolean!
}

type AddressWithDefault {
  id: String!
  country: String!
  city: String!
  state: String!
  line1: String!
  line2: String!
  postal_code: String!
  userId: String!
  default: Boolean!
}

type Mutation {
  createShop(data: ShopCreateInput!): Shop!
  createShopItem(data: ShopItemCreateInput!): ShopItem!
  removeFromOrder(removeFromOrderInput: RemoveFromOrderInput!): Order
  addToOrder(addToOrderInput: AddToOrderInput!): [Order!]!
  addPaymentInfo(addPaymentInfoInput: AddPaymentInfoInput!): PaymentMethod!
  deletePaymentInfo(deletePaymentInfoInput: DeletePaymentInfoInput!): PaymentMethod!
  payCurrentOrder(payCurrentOrderInput: PayCurrentOrderInput!): Order!
  addAddress(addAddressInput: AddAddressInput!): [Address!]!
  updateDefaultAddress(updateDefaultAddressInput: UpdateDefaultAddressInput!): Address!
  removeAddress(addAddressInput: DeleteAddressInput!): Address!
  signUp(signUpInput: SignUpInput!): User!
}

input ShopCreateInput {
  id: String
  email: String!
  username: String!
  password: String!
  shopItems: ShopItemCreateManyWithoutShopInput
}

input ShopItemCreateManyWithoutShopInput {
  create: [ShopItemCreateWithoutShopInput!]
  connect: [ShopItemWhereUniqueInput!]
}

input ShopItemCreateWithoutShopInput {
  id: String
  createdAt: DateTime
  name: String!
  description: String!
  price: Float!
  imageUrl: String!
  orderItemCounts: OrderItemCountCreateManyWithoutShopItemInput
  refunds: RefundCreateManyWithoutShopItemInput
}

input OrderItemCountCreateManyWithoutShopItemInput {
  create: [OrderItemCountCreateWithoutShopItemInput!]
  connect: [OrderItemCountWhereUniqueInput!]
}

input OrderItemCountCreateWithoutShopItemInput {
  id: String
  price: Float!
  count: Int!
  deletedAt: DateTime
  order: OrderCreateOneWithoutOrderItemCountInput!
}

input OrderCreateOneWithoutOrderItemCountInput {
  create: OrderCreateWithoutOrderItemCountInput
  connect: OrderWhereUniqueInput
}

input OrderCreateWithoutOrderItemCountInput {
  id: String
  paymentIntentId: String
  price: Float
  deletedAt: DateTime
  owner: UserCreateOneWithoutOrdersInput!
  MultiOrder: MultiOrderCreateOneWithoutOrdersInput
  PaymentOrder: PaymentOrderCreateOneWithoutOrderInput
}

input UserCreateOneWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutOrdersInput {
  id: String
  email: String!
  username: String!
  password: String!
  dob: DateTime!
  stripe_cust_id: String
  defaultAddressId: String
  addresses: AddressCreateManyWithoutUserInput
}

input AddressCreateManyWithoutUserInput {
  create: [AddressCreateWithoutUserInput!]
  connect: [AddressWhereUniqueInput!]
}

input AddressCreateWithoutUserInput {
  id: String
  country: String!
  city: String!
  state: String!
  line1: String!
  line2: String!
  postal_code: String!
}

input MultiOrderCreateOneWithoutOrdersInput {
  create: MultiOrderCreateWithoutOrdersInput
  connect: MultiOrderWhereUniqueInput
}

input MultiOrderCreateWithoutOrdersInput {
  id: String
  paymentIntentId: String
  PaymentMultiOrder: PaymentMultiOrderCreateOneWithoutMultiOrderInput
}

input PaymentMultiOrderCreateOneWithoutMultiOrderInput {
  create: PaymentMultiOrderCreateWithoutMultiOrderInput
  connect: PaymentMultiOrderWhereUniqueInput
}

input PaymentMultiOrderCreateWithoutMultiOrderInput {
  id: String
  paymentStatus: PaymentStatus
  paymentIntentId: String!
}

input PaymentMultiOrderWhereUniqueInput {
  id: String
}

input MultiOrderWhereUniqueInput {
  id: String
}

input PaymentOrderCreateOneWithoutOrderInput {
  create: PaymentOrderCreateWithoutOrderInput
  connect: PaymentOrderWhereUniqueInput
}

input PaymentOrderCreateWithoutOrderInput {
  id: String
  paymentStatus: PaymentStatus
  paymentIntentId: String!
}

input PaymentOrderWhereUniqueInput {
  id: String
}

input RefundCreateManyWithoutShopItemInput {
  create: [RefundCreateWithoutShopItemInput!]
  connect: [RefundWhereUniqueInput!]
}

input RefundCreateWithoutShopItemInput {
  id: String
  description: String!
  paymentIntentId: String!
  stripeRefundId: String!
}

input ShopItemCreateInput {
  id: String
  createdAt: DateTime
  name: String!
  description: String!
  price: Float!
  imageUrl: String!
  shop: ShopCreateOneWithoutShopItemsInput!
  orderItemCounts: OrderItemCountCreateManyWithoutShopItemInput
  refunds: RefundCreateManyWithoutShopItemInput
}

input ShopCreateOneWithoutShopItemsInput {
  create: ShopCreateWithoutShopItemsInput
  connect: ShopWhereUniqueInput
}

input ShopCreateWithoutShopItemsInput {
  id: String
  email: String!
  username: String!
  password: String!
}

input ShopWhereUniqueInput {
  id: String
  email: String
  username: String
}

input RemoveFromOrderInput {
  item_id: String!
  buyer_id: String!
}

input AddToOrderInput {
  item_id: String!
  buyer_id: String!
}

input AddPaymentInfoInput {
  stripe_cust_id: String!
  token: String!
  default: Boolean
}

input DeletePaymentInfoInput {
  paymentMethodId: String!
}

input PayCurrentOrderInput {
  user_id: String!
  order_id: String!
  payment_method_id: String!
}

input AddAddressInput {
  country: String!
  city: String!
  state: String!
  line1: String!
  line2: String!
  postal_code: String!
  default: Boolean!
}

input UpdateDefaultAddressInput {
  id: String!
}

input DeleteAddressInput {
  id: String!
}

input SignUpInput {
  email: String!
  password: String!
  displayName: String!
  firstName: String!
  lastName: String!
  dob: DateTime!
}
